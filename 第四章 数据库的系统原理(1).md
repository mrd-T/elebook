# 第四章 数据库的系统原理

## 4.1 查询执行过程

在数据库管理系统中，查询的执行过程是指一条 SQL 查询语句转化为数据库能够理解并执行的操作的过程，一般包含以下几个步骤：解析、语义分析、查询重写、查询优化、查询执行。

![4](C:\Users\DengSama\Desktop\数字化教材\image\4.png)

- 解析：首先对 SQL 查询进行语法分析，确保其符合 SQL 语法规则。再由解析器(Paser)将查询转化为抽象语法树(Abstract Syntax Tree，AST)，语法树表示了查询中的各个部分及其关系；

- 语义分析：也称为 Binding。在绑定阶段将 SQL语句中的标识符（如表名、列名）与数据库的实际对象（如数据库中存储的表和列）关联起来，包括检查表和列是否存在，用户是否有权访问这些对象。此外，还可能涉及数据类型的检查，确保算子和函数调用在类型上合法；

- 查询重写：通过对原始查询进行重写，保持语义不变，但提升效率，从而优化查询性能。例如，将查询中引用的视图直接替换为视图定义的 SQL；

- 查询优化：查询优化包括 逻辑优化 和 物理优化。逻辑优化通过进行关系代数的等价变换对查询的逻辑执行计划进行优化，例如谓词下推等；物理优化，选择最佳的物理操作，包括访问路径选择、算子执行路径选择；

- 查询执行：查询执行器按照执行计划的步骤，逐步从数据库中获取或修改数据。

从逻辑上讲，关系数据库的查询执行过程就是 '查询 -> 语法树 -> 逻辑优化 -> 物理优化 -> 查询执行'，分为三个重要的过程：解析、查询优化和查询执行。

## 4.2 索引

在数据管理系统中，索引是优化数据访问的关键技术，可以加快查询和数据检索的速度，被广泛应用于各种数据访问场景。通过避免对整个数据集进行扫描，从而更加高效地处理大规模数据。

**$B^+$树** 

$B^+$树是一种平衡的多路搜索树，在提供高效的数据插入、删除和查找操作，同时保持树的平衡和存储利用率。$B^+$树由多个节点组成，对于一个 m 阶$B^+$树来说，每个节点最多可容纳 m 个键和 m+1 个指向子节点的指针。这些节点在逻辑上可以分为三类：根节点、内部节点和叶节点：

- 根节点：树的顶部节点，可能包含 1个到 m个键，以及相应的 m+1 个指针；
- 内部节点：处于根节点与叶节点之间的节点称为内部节点。所有的非叶节点不存储数据，只记录子树上的最大键值，用于数据索引。每个内部节点至少包含 $[\frac{m}{2}]$ 个键和相应数量的指针，最多包含 m 个键和 m+1 个指针。对于第 i 个指针来说，其子树上的键值范围在 $[k_{i-1},k_i)$ 之间，其中$k_{i-1}$ 表示存储的第 i 个键值；
- 叶节点：树的最底层为叶节点，该节点类型存储了所有的键和数据值。记叶节点的容量为 b，则每个叶节点的记录数量需要满足$[\frac{b}{2}]\leq n\leq b$ ，同时每个叶节点内部的数据会按键排序，为了方便范围查询，叶节点之间还会用指针串联起来。

‘查找操作’：要查找某个键值，需要从根节点开始，从上到下递归地遍历树。在每个非叶节点上，通过比较键可以确定下一个搜索的节点，一直遍历到叶节点，最后只需要在叶节点上的有序数据中进行二分查找即可，最终查找成功。

'插入操作'：进行插入操作时，首先需要找到新写入键值所在的叶节点，这个过程与查找操作相同。接下来，将数据写入相应的叶节点。如果该叶节点已满，则需要进行分裂操作，分裂之后需要将新叶节点的最小键值复制到其父节点中。如果该操作后，父节点也变满，则需要进行递归分裂操作。

'删除操作'：进行删除操作时，需要找到删除键值所在的叶节点，并在叶节点中通过二分查找确定请求数据的位置，之后根据不同情况进行操作。首先删除对应的记录，如果删除后叶节点的数据量仍大于等于$[\frac{b}{2}]$，则操作完成；否则需要向有多余记录的兄弟节点（大于或等于$[\frac{b}{2}]$​）借一个记录，同时更新父节点中对应的键值；在兄弟节点也没有多余记录的情况下，需要合并节点，将当前节点和兄弟节点合并为一个节点，之后在父节点中同样需要删除对应的记录，回到第一步进行递归操作。

$举例$：

对于设计一个学生表，在学生表中，**`studentid`** 作为 B+树的索引键，而 **`name`** 作为记录的数据部分。B+树的内部节点存储 `studentid` 作为索引，用于快速定位叶子节点，而叶子节点则包含完整的学生数据（`studentid` 和 `name`）。

内部节点：存储若干个 `studentid`，用于引导查找过程。

叶子节点：存储完整的学生记录，包括 `studentid` 和 `name`，并通过指针将相邻的叶子节点相连，以支持顺序遍历。

我们在插入过程中，插入2013就要进行分裂，以2012为内部节点分为两边。

删除过程是一样的原理，查找的时候因为B+树层数比较少所以查询速度更快

**哈希索引**

哈希索引的基本思想是将数据通过哈希函数映射到一个特定的位置，从而快速定位所需的记录。哈希索引主要用于基于等值查询的场景，比如查询某个特定的主键或列的值。由于哈希索引通过计算哈希值直接找到数据存放的位置，因此基于哈希索引的等值查询通常具有 O(1)的时间复杂度，且哈希索引的结构比较简单，不需要维护复杂的层次结构，占用的存储空间较少。

‘插入操作’：插入新纪录时，通过哈希函数计算该记录键的哈希值，然后将记录插入对应的哈希桶；

'查询数据'：当执行等值查询时，会对需要查找的键应用哈希函数，查找相应的哈希桶，快速定位该记录；

'冲突处理'：如果不同的键值计算出了相同的哈希值，也即发生了哈希冲突的情况，会将多个记录放在同一个桶中，通常会采用链表或开放寻址法来处理冲突。

例如:

  我们建立一个桶容量为13的hash索引，在我们插入过程中，他会先%13找到位置，如没有值，直接插入，如果有，在他的后面连接一个索引，查找和删除是类似原理



## 4.3 查询执行引擎

### 4.3.1 执行引擎框架

执行引擎框架定义了系统如何执行查询计划、指定查询计划的执行顺序以及在算子之间传递的数据内容。不同的执行引擎框架针对的工作负载不同，需要根据实际业务需求进行权衡。

'迭代模型'（Pipeline/Volcano/Iterator Model）也被称为瀑布模型或流水线模型，是最常见的开发模型。大多数关系数据库都使用迭代模型，例如 Db2、SQL Server、PostgreSQL、Oracle和 MySQL等。迭代模型将关系代数中的每个操作抽象为一个算子(Operator)，并为每个算子实现 Open、Next、Close三个接口函数：

- Open 函数，用于初始化本算子的一些结构，例如启动工作线程、构建哈希表等；
- Next 函数，负责每次从下游算子获取一条或一批数据，然后进行本算子的计算工作，例如执行过滤、投影或排序等，然后返回给上层算子；
- Close 函数，在 Next 函数计算完成后释放所有的资源并清理状态。

迭代模型将整个 SQL 构建成一个算子树，查询树自顶向下调用 Next() 接口，数据则自底向上被拉取处理。

![1](C:\Users\DengSama\Desktop\数字化教材\image\1.png)

物化模型(Materialization Model)类似火山模型，每个算子在获取所有输入并处理完成后，会将结果一次性返回。这种将处理结果一次性输出的方式可以理解为对单个算子的处理结果进行了“物化”。物化模型的工作方式会导致每个算子在输入和输出之间存在一定的阻塞。
![3](C:\Users\DengSama\Desktop\数字化教材\image\3.png)

### 4.3.2 算子实现

查询执行计划中的相同算子可以有多种不同的实现方式，而每种实现方式的执行效率可能会有显著差异。以连接算子为例，常见的实现方案包括：嵌套循环连接(Nest Loop)和哈希连接(Hash Join)，它们在不同的场景下表现出不同的性能。

**嵌套循环连接**
这是最简单的连接算法，适用于较小的数据集，其原理是对于外部表的每一行，逐步扫描内部表，寻找满足连接条件的行。

例如，对于下面的查询语句：

```sql
select x.sno as sno,x.name as name ,y.grade as grade,y.course as course 
from Student as x 
join Transcript as y 
on x.sno=y.sno;
```

其执行过程如下所示：

.../



**哈希连接**
哈希连接通常用于等值连接，其原理是首先对一张较小的表（称为构建表）建立哈希表，然后对另一张表（称为探测表）中的每一行根据哈希值进行匹配。对于和上述相同的查询：

```sql
select x.sno as sno,x.name as name ,y.grade as grade,y.course as course 
from Student as x 
join Transcript as y 
on x.sno=y.sno;
```

其执行过程如下所示：

.../



## 4.4 查询优化器

### 4.4.1  路径选择优化

### 4.4.2  连接算子选择优化

### 4.4.3 多表连接顺序优化





## 4.3 查询优化器

查询优化器是数据库系统中的一个关键组件，负责对语法分析生成的查询树进行逻辑优化，生成对应的逻辑查询计划，再在此基础上，进行物理优化，确定一种执行代价最小的物理查询计划。

逻辑优化改变查询语句中算子的次序和组合，但不涉及底层存取路径，同时对于一个查询语句的算子有多种实现方案，它们的执行效率各不相同。所以物理优化就是需要选择高效合理的操作算子、数据访问路径和查询树结构，得到相对最优的查询计划。

### 4.3.1 代价模型

**运算代价**估计是物理优化的基础，用于估算数据库执行查询时的成本，对于查询树中不同操作算子（如扫描、连接、排序等）都有相应的代价。

**代价的构成**：

- I/O代价：指从磁盘读取或写入数据的代价，读取、写入的数据量越大，I/O成本越高。在大多数数据库中，I/O是最耗时的操作；
- CPU代价：指处理数据的计算开销。相同数据量下，不同算子对应的CPU开销各不相同，通常连接和排序等操作，CPU开销比过滤要高；
- 内存代价：指执行过程中占用的内存资源。如果算子需要大量的中间数据，可能会消耗更多的内存。内存不足时，数据库需要将部分数据存储到磁盘，增加I/O 成本；
- 通信代价：对于分布式数据库，还需要考虑网络通信代价。

**运算的代价**：每个操作算子都有不同的代价

- 全表扫描：需要读取整个表的数据，I/O代价很高；
- 索引扫描：利用索引定位数据块，只读取部分数据块，I/O代价相对较低；
- 嵌套循环连接：两表连接时，使用双重循环进行匹配，代价与两表大小成正比；
- 排序：排序通常需要在内存和磁盘中进行操作，数据量大的情况下，代价会显著增加。

数据库系统通过估算这些操作算子的代价，估计不同物理计划的开销，从而选择最优计划。

**代价模型**是物理优化的核心手段，用于为不同物理计划估算总成本。在数据库系统中，代价模型主要是通过对运算代价求和，来表示物理计划的整体执行成本。

代价模型通过依赖数据库中的统计信息来进行估算，例如如果查询是等值连接且该属性列上存在索引的话，代价模型就可能推荐索引扫描，而不是代价更大的全表扫描。统计信息有许多种类，常见的有：

- 对于每个基本表：元组总数、元组长度、占用的块数、占用的溢出块数等；
- 对于基本表的每个列：该列不同值的个数、选择率、最大值、最小值、是否建立索引、索引的种类等；
- 对于索引（以$B^+$树为例）：索引的层数、不同索引值的个数、索引的选择基数、索引的叶节点数等。

代价模型不仅估算单个操作算子的成本，还需要估算整个查询树的总成本。对于复杂的查询，如包含连接和子查询的情况，代价模型还会通过估计中间结果集的大小从而将所有操作算子的代价累计。

### 4.3.2选择最优计划

对于查询优化后生成的逻辑计划，查询优化器会生成不同的物理计划。不同的物理计划可能涉及不同的表扫描方式（如全表扫描、索引扫描）、不同的连接方法（循环嵌套连接、哈希连接、排序连接）以及对于多表连接时不同的连接顺序等。

对于多表连接顺序的搜索，相较于搜索整个逻辑计划的执行空间，查询优化器一般选择以左深树的进行连接的逻辑计划。

**左深树**：如果查询计划中每个连接算子的右侧输入是一个关系（基本表），而不是连接后的中间结果，那就认为它是左深树形态的。

但是对于给定树叶数目的可能的左深树的数目仍是很大的，这时查询优化器为了选择相对最优的物理查询计划，会有一定策略：

- 动态规划：对于 连接的表的个数小于10时，一般考虑使用动态规划方法枚举所有可能的左深树的执行计划。
- 随机算法：如果多表连接的表的个数大于10时，为了取得物理计划的成本与执行优化过程的成本之间的平衡，会使用如遗传算法这样的随机算法。

通过物理优化，查询优化器确定查询执行代价最低的物理计划，再交由执行器执行具体的查询并得出查询结果。
